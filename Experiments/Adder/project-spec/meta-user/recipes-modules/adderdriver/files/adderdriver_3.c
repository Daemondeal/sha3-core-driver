/**
 * Qui vogliamo usare cdev e le classi, non ci servira' piu' creare
 * il file a mano con mknod
*/

/* Queste prime tre inlcude le userai praticamente sempre*/
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
/* Ci serviranno anche queste */
#include <linux/fs.h>
#include <linux/string.h>
#include <asm/uaccess.h>
/* Per questa versione dobbiamo aggiungere le seguenti librerie */
#include <linux/device.h>
#include <linux/cdev.h>


/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("Ivan Piri was here");
MODULE_DESCRIPTION
    ("adderdriver - loadable module template generated by petalinux-create -t modules");


// Nome della classe che andremo a creare
#define CLASS_NAME "ADDER_TEST"

/* Variabili statiche */
static char ker_buf[100];
static int curr_len = 0;
static int dev_open(struct inode *inod, struct file *fil);
static ssize_t dev_read(struct file *fil, char *buf, size_t len, loff_t *off);
static ssize_t dev_write(struct file *fil, const char *buf, size_t len, loff_t *off);
static int dev_release(struct inode *inod, struct file *fil);

/* A tutte le variabili statiche di prima aggiungiamo */
static struct class *driver_class = NULL;
static dev_t first;
static struct cdev c_dev;

static struct file_operations fops = {
	.read=dev_read,
	.write=dev_write,
	.open=dev_open,
	.release=dev_release,
};

static int dev_open(struct inode *inod, struct file *fil)
{
	pr_info("Device adderModule opened \n");
	return 0;
}

static int dev_release(struct inode *inod, struct file *fil)
{
	pr_info("Device adderModule closed \n");
	return 0;
}

static ssize_t dev_read(struct file *fil, char *buf, size_t len, loff_t *off)
{
	// Semplicemente copiamo da kernel space a user space
	pr_info("Reading device rx: %d \n", len);
	copy_to_user(buf, ker_buf, curr_len);
	// Se non ritorni zero la cat va avanti all'infinito
	return curr_len; 
}

static ssize_t dev_write(struct file *fil, const char *buf, size_t len, loff_t *off)
{
	// Copiamo da user space a kernel space
	pr_info("Writing device tx: %d \n", len);
	copy_from_user(ker_buf, buf, len);
	ker_buf[len] = 0;
	curr_len = len;
	return len;
}

/**
 * Stiamo allocando semplicemente un banale char device
 * Per eseguire:
 * - modprobe adderdriver
 * - mknod /dev/nomechevolete c 100 0
 * - echo/cat sul file in /dev/nomechevolete
 * 
 * Stiamo facendo tutto a mano ma c'e' un modo piu' intelligente, guarda il prossimo file
*/
static int init_hello(void)
{
	pr_info("Hello from module adderdriver\n");

	// Qua le vere modifiche
	// Questa mi da il major number, non ricordo cosa sia l'ultimo parametro
	if (alloc_chrdev_region(&first, 0, 1, "IvanPiri") < 0)
	{
		return -1;
	}

	// Crea la classe dentro sys/class
	driver_class = class_create(THIS_MODULE, CLASS_NAME);
	if (driver_class == NULL)
	{
		pr_info("Creation of the class failed\n");
		unregister_chrdev_region(first, 1);
		return -1;
	}

	// Crea il device in /dev/
	if (device_create(driver_class, NULL, first, NULL, "testadderdevice") == NULL)
	{
		pr_info("Creation of the device failed\n");
		class_destroy(driver_class);
		unregister_chrdev_region(first, 1);
		return -1;
	}

	// Lo inizializza come character device
	cdev_init(&c_dev, &fops);
	if (cdev_add(&c_dev, first, 1) == -1)
	{
		pr_info("Creation of the character device failed\n");
		device_destroy(driver_class, first);
		class_destroy(driver_class);
		unregister_chrdev_region(first, 1);
		return -1;
	}
	return 0;
}

static void exit_hello(void)
{
	cdev_del(&c_dev);
	device_destroy(driver_class, first);
	class_destroy(driver_class);
	pr_info("Goodbye from module adderdriver\n");
}

module_init(init_hello);
module_exit(exit_hello);

