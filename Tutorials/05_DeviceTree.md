# Device tree

All of this is based on this youtube video [device tree](https://www.youtube.com/watch?v=Nz6aBffv-Ek). I knew nothing about the device tree so if you already know this stuff feel free to skip it.


## Intro

So we have a SOC with all the peripherals. The problem we need to solve is **how can the OS know all the devices we have in a system**? That depends from the device we're talking about, for example

- in the case of a USB drive, it's discoverable at runtime, we plug a usb drive in the pc and it get's recognized (also all the PCI stuff works like this, think of when you plug in a graphics card)
- not all buses are like this tho, I2C, SPI, all the memory mapped I/O are **non-discoverable**

Why should we bother with all of this? Because the OS needs to know all the component details in order to be able to interface with it, otherwise we can only do `peek 0x43C00000 12` etc.

How do we solve this problem? With the **device tree**

## Device tree 101

Essentially it's a tree data structure describing the hardware.
The workflow something like:

- you write a device tree source in a `.dts` file
- that file get's compiled to to a device tree blob representation (a `.dtb` file)
- the OS reads that `.dtb` file understanding what hardware is available and how it's organized

> If you want to explore the default one generated by the petalinux tool go to `<proj-root>/components/plnx_workspace/device-tree`

What usually happens during boot is that the device tree is loaded by the boot loader (u-boot) and passed as is to the kernel

### Basic idea

All the hw is represented as a tree of nodes to we'll have a root and all the children (which remember are also nodes _sorry but i had to, i love the tree data structure_).

Each node will have a **name** and some **properties**. The node represents the **hw block**, the properties all the **characteristics** of that particular block (== the block will be our custom component onto the fpga).

If the component we are describing has some sub-components (for example an I2C interrupt controller may have an eeprom attached, the eeprom will be a subnode -a child- of the node representing the I2C interrupt controller).

If we want we can theoretically split a `.dts` file into multiple `.dtsi` files (device tree source include) but naah, who want's to do things the right way (jk, but it's only if we want to reuse devices in different projects).

> You can explore the device tree at `/sys/firmware/devicetree/base` and also unpack it using `dtc -I fs /sys/firmware/devicetree/base`

### Device tree overlays

Devices with flexibility (like a fpga) are hard do describe in a static way, because we would be forced to write a new
`.dts` file every time we modify the IP onto the fpga.
It would be much better if we were able to write a single device tree source for the fpga and than a new only for the custom ip inside that get's loaded at runtime.

This would be possible if we were using something like a raspberry but unfortunately linux does not support this so yeah no luck, I could've omitted this but just for the sake of completeness i'm mentioning it.

### Where can we learn the syntax

- [Inside this pdf](/Tutorials/Resources/docs/devicetree-specification-v0.4.pdf)
- [In the documentation of the linux kernel](https://github.com/torvalds/linux/tree/master/Documentation/devicetree/bindings/)

### Considerations

> We need to describe the hardware, not how is used by an operating system

## Some properties

### `compatible` property

It's a list of strings from the most specific to the lest one, it describes the specific bindings to which the node complies. What does this mean? It's essentially saying "this node is describing this particular device" and it's used by the OS to find the specific driver to use since it's also describing the programming model (== how it's made internally).

### `reg` propery

The meaning depends from the device it's associated with. If we are working with for example a memory mapped device, the `reg` property will define the base address of the component and the dimension of all the registers.

### `interrupts` property

It specifies which interrupt lines are used by the device, which interrupt controller are they connected to

### `clocks` property

Which clocks are connected to the device and from whick clock controller

### `dmas` property

Which DMA controller and channels are used by the device

### `status: ok` property

If the property is enabled or not (if not present the device is invisible, like it's not even there)

## Cells

Inside a node there is the concept of **cell** to encode an integer

```
soc {
    /* Property con una cell */
    foo = <0x12345678> // Only one int, value of 32 bits
    bar = <0x12345678 0x12345678> // 64 bit value
}
```

## Some examples

### Example 1

In this example we show how to define the number of cells are used in the sub nodes to encode the address and the size in the `reg` property.

- `compatible = "simple-bus"` is telling that every subnode describes a memory-mapped device
- than we have the I2C controller that has a `reg` property in which we have the address of the base address and the size of the registers area
- than we override those values saying that in the child nodes we'll have only the base address but no register area size and indeed in the eeprom we only have the address

```c
soc {
    compatible = "simple-bus";
    #address-cells = <1>;
    #size-cells = <1>;

    i2c@f1001000 {
        reg = <0xf1001000 0x1000>;
        #address-cells = <1>;
        #size-cells = <0>;

        eeprom@52 {
            reg = <0x52>;
        };
    };
};
```

### Example 2

In this example:

- the first node represents an interrupt controller and with whe `#interrupt-cells = <2>` is saying that every devices that will use as an interrupt controller `intc` (like the one below) must have two cells

```c
soc {
    intc: interrupt-controller@f1002000 {
        compatible = "foo,bar-inc";
        reg = <0xf1002000 ox1000>
        interrupt-controller;
        #interrupt-cells = <2>;
    };

    i2c@f1001000 {
        interrupt-parent = <&intc>;
        /* We must have two cells*/
        interrupts = <12 24>;
    }
}
```

This idea works for all the various types of cells.
