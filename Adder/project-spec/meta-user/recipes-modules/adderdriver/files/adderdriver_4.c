/**
 * Qui vogliamo usare cdev e le classi, non ci servira' piu' creare
 * il file a mano con mknod
*/

/* Queste prime tre inlcude le userai praticamente sempre*/
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
/* Ci serviranno anche queste */
#include <linux/fs.h>
#include <linux/string.h>
#include <asm/uaccess.h>
/* Per questa versione dobbiamo aggiungere le seguenti librerie */
#include <linux/device.h>
#include <linux/cdev.h>


/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("Xilinx Inc.");
MODULE_DESCRIPTION
    ("adderdriver - loadable module template generated by petalinux-create -t modules");


// Nome della classe che andremo a creare
#define CLASS_NAME "ADDER_TEST"

/* Variabili statiche */
static char ker_buf[100];
static int curr_len = 0;
static int dev_open(struct inode *inod, struct file *fil);
static ssize_t dev_read(struct file *fil, char *buf, size_t len, loff_t *off);
static ssize_t dev_write(struct file *fil, const char *buf, size_t len, loff_t *off);
static int dev_release(struct inode *inod, struct file *fil);
static ssize_t write_attrs(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
static ssize_t read_attrs(struct device *dev, struct device_attribute *attr, char *buf);
/* A tutte le variabili statiche di prima aggiungiamo */
static struct class *driver_class = NULL;
static dev_t first;
static struct cdev c_dev;

/* Ora aggiungiamo un po' di logica */
static int operand_a = 0;
static int operand_b = 0;
static int result = 0;
static int result_ready = 0;
static struct device *my_dev;

/* Ora gli attributi */
/* Dovrebbe essere: nome_attributo, r/w, callback_lettura, callback_scrittura */
static DEVICE_ATTR(write_reg_1, S_IWUSR, NULL, write_attrs);
static DEVICE_ATTR(write_reg_2, S_IWUSR, NULL, write_attrs);
static DEVICE_ATTR(go, S_IWUSR, NULL, write_attrs);
static DEVICE_ATTR(read, S_IRUGO, read_attrs, NULL);

static struct file_operations fops = {
	.read=dev_read,
	.write=dev_write,
	.open=dev_open,
	.release=dev_release,
};

static int dev_open(struct inode *inod, struct file *fil)
{
	pr_info("Device adderModule opened \n");
	return 0;
}

static int dev_release(struct inode *inod, struct file *fil)
{
	pr_info("Device adderModule closed \n");
	return 0;
}

static ssize_t dev_read(struct file *fil, char *buf, size_t len, loff_t *off)
{
	if (result_ready)
	{
		result_ready = 0;
		pr_info("Reading device rx: %d \n", (int)len);
		int n = sprintf(ker_buf, "%d\n", result);
		copy_to_user(buf, ker_buf, n);
		pr_info("Returning %s rx: %d\n", ker_buf, n);
		return n;
	}
	return 0;
}

static ssize_t dev_write(struct file *fil, const char *buf, size_t len, loff_t *off)
{
	// Copiamo da user space a kernel space
	copy_from_user(ker_buf, buf, len);
	sscanf(ker_buf, "%d,%d", &operand_a, &operand_b);
	ker_buf[len] = 0;
	pr_info("Received the following operands <%d + %d>", operand_a, operand_b);
	return len;
}

/**
 * Aggiungiamo le funzioni che si occupano degli attributi
*/
static ssize_t write_attrs(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
	// TODO: implementa effettivamente le operazioni
	pr_info("Received %d bytes attribute %s\n", (int)count, buf);
	return count;
}


static ssize_t read_attrs(struct device *dev, struct device_attribute *attr, char *buf)
{
	sprintf(buf, "Result is: %d\n", result);
	return strlen(buf) + 1;
}


/**
 * Stiamo allocando semplicemente un banale char device
 * Per eseguire:
 * - modprobe adderdriver
 * - mknod /dev/nomechevolete c 100 0
 * - echo/cat sul file in /dev/nomechevolete
 * 
 * Stiamo facendo tutto a mano ma c'e' un modo piu' intelligente, guarda il prossimo file
*/
static int init_hello(void)
{
	pr_info("Hello from module adderdriver\n");

	// Qua le vere modifiche
	// Questa mi da il major number, non ricordo cosa sia l'ultimo parametro
	if (alloc_chrdev_region(&first, 0, 1, "IvanPiri") < 0)
	{
		return -1;
	}

	// Crea la classe dentro sys/class
	driver_class = class_create(THIS_MODULE, CLASS_NAME);
	if (driver_class == NULL)
	{
		pr_info("Creation of the class failed\n");
		unregister_chrdev_region(first, 1);
		return -1;
	}

	// Crea il device in /dev/
	my_dev = device_create(driver_class, NULL, first, NULL, "testadderdevice");
	if (my_dev == NULL)
	{ 
		pr_info("Creation of the device failed\n");
		class_destroy(driver_class);
		unregister_chrdev_region(first, 1);
		return -1;
	}

	// Inizializza il character device
	cdev_init(&c_dev, &fops);
	if (cdev_add(&c_dev, first, 1) == -1)
	{
		pr_info("Creation of the character device failed\n");
		device_destroy(driver_class, first);
		class_destroy(driver_class);
		unregister_chrdev_region(first, 1);
		return -1;
	}

	// Ora creiamo anche gli attributi dentro sysfs (/sys/class/ADDER_TEST/testadder/* )
	if (device_create_file(my_dev, &dev_attr_write_reg_1) < 0)
	{
		pr_info("Error in the creation of the attribute\n");
	}
	// Ripeti questa cosa in base a quanti attributi vuoi
	if (device_create_file(my_dev, &dev_attr_write_reg_2) < 0)
	{
		pr_info("Error in the creation of the attribute\n");
	}
	if (device_create_file(my_dev, &dev_attr_go) < 0)
	{
		pr_info("Error in the creation of the attribute\n");
	}
	if (device_create_file(my_dev, &dev_attr_read) < 0)
	{
		pr_info("Error in the creation of the attribute\n");
	}

	return 0;
}

static void exit_hello(void)
{
	cdev_del(&c_dev);
	device_destroy(driver_class, first);
	class_destroy(driver_class);
	pr_info("Goodbye from module adderdriver\n");
}

module_init(init_hello);
module_exit(exit_hello);

